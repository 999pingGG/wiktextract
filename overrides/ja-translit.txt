TITLE: Module:ja-translit
local export = {}
local data = mw.loadData'Module:ja-translit/data'

function export.kana_to_romaji(text, options)
	options = options or {}

	local result = {[0] = ''}
	local result_sp = {}
	
	local function getlast(i_start, predicate_good, predicate_bad)
		local in_xml = false
		for i = i_start or #result, 1, -1 do
			if in_xml then
				if result[i] == '<' then in_xml = false end
			elseif result[i] == '>' then
				in_xml = true
			else
				if (predicate_bad or function(index)
					return result_sp[index] == 'stop'
				end)(i) then break end
				if (predicate_good or function(index)
					return result[index]:len() > 0 and result_sp[index] ~= '\''
				end)(i) then return i end
			end
		end
		return 0
	end
	
	local i_last
	for c in mw.ustring.gsub((mw.ustring.gsub(text, '()([ゝヽゞヾ]+)',  function(p1, m2) -- repetition mark
		local len = mw.ustring.len(m2)
		local sec_rep = mw.ustring.sub(text, p1 - len, p1 - 1)
		for i = len, 1, -1 do
			if ({['ゞ'] = true, ['ヾ'] = true})[mw.ustring.sub(m2, i, i)] then
				sec_rep = mw.ustring.sub(sec_rep, 1, i) .. '゙' .. mw.ustring.sub(sec_rep, i + 1)
			end
		end
		return sec_rep
	end)), '[ァ-ヶ]', function(m1) -- kata to hira
		return mw.ustring.char(mw.ustring.codepoint(m1) - 96)
	end):gmatch'.[\128-\191]*' do
		local rc = options.hist and data.rom_hist[c] or data.rom[c] or c
		result_sp[#result + 1] = data.rom_sp[c]
		i_last = getlast()
		
		if options.keep_period and c == '.' then rc = '.'
		elseif c:match'%a' then result_sp[#result + 1] = 'stop' end
		
		if not options.hist then --はへ
			if data.flag_hahe[result_sp[i_last]] and (mw.ustring.match(c, '[-%.ー゙゚]') or  rc:match'%a' or  rc == data.rom['っ']) then
				result[i_last] = result_sp[i_last]
				result_sp[i_last] = nil
			elseif data.flag_hahe[result_sp[#result + 1]] and (options.phonetic or result_sp[getlast(nil, function(i)
				return result[i]:len() > 0 and result_sp[i] ~= '\'' or result_sp[i] == 'stop'
			end, function(i) return false end)] == 'stop'  or result[i_last]:match'[-%a]' or result[i_last] == data.rom['っ']) then
				rc = result_sp[#result + 1]
				result_sp[#result + 1] = nil
			end
		end
		
		if result_sp[#result + 1] == 'voiced' then --voicing
			result[i_last] = result[i_last]:gsub('^..', data.tr_voicing):gsub('^.', data.tr_voicing)
		elseif result_sp[#result + 1] == 'semivoiced' then
			result[i_last] = result[i_last]:gsub('^.', data.tr_semivoicing)
		end
		
		if rc:match'%a' and mw.ustring.match(result[i_last], '^[,%.?!:)”†]$') then --space and punctuations
			result[i_last] = result[i_last] .. ' '
		elseif mw.ustring.match(rc, '^[(“]$') and result[i_last]:match'%a' then
			rc = ' ' .. rc
		end
		
		if rc:match('^[kgszjtdcnhpbmyrw]') then --gemination
			local c_gem = rc:sub(1, 2) == 'ch' and 't' or rc:sub(1, 1)
			local i = i_last
			while result_sp[i] == 'gem' do
				result[i] = c_gem
				i = getlast(i -1)
			end
		end
		
		if result[i_last] == 'n' and rc:match(options.hist and '^[aiueoyw]' or '^[aiueoy]') then --na vs n'a
			rc = data.rom['っ'] .. rc
		end
		
		local r_lastlast = result[i_last]:sub(-1) --vowel clusters
		if r_lastlast:match'[aiueo]' then
			if c == 'ー' then
				result[i_last] = result[i_last] .. r_lastlast
			elseif rc:match'^%-[yw]' or options.hist and (r_lastlast == 'i' and rc:sub(1, 1) == 'y' or r_lastlast == 'u' and rc:sub(1, 1) == 'w') then
				if rc:sub(1, 1) == '-' then rc = rc:sub(2) end
				result[i_last] = result[i_last]:sub(1, -2)
				if rc:sub(1, 1) == 'y' and data.flag_postalveolarconsonant[result[i_last]] then rc = rc:sub(2) end
			elseif rc:match'^%-[aiueo]$' then
				rc = rc:sub(2)
				if r_lastlast == rc then
					result[i_last] = result[i_last] .. r_lastlast
					rc = ''
				elseif data.flag_specialconsonant[result[i_last]] then
					result[i_last] = result[i_last]:sub(1, -2)
				elseif r_lastlast == 'i' then
					result[i_last] = result[i_last]:sub(1, -2) .. 'y'
				elseif r_lastlast:match'[ou]' and rc ~= 'u' then
					result[i_last] = result[i_last]:sub(1, -2) .. 'w'
				else
					result[i_last] = result[i_last]:sub(1, -2)
				end
			elseif rc:match'^[aiueo]$' then
				if not options.hist and not options.phonetic and data.tr_long[r_lastlast .. rc] and not result[i_last]:match'[aiueo][aiueo]$' then
					result[i_last] = result[i_last] .. rc
					rc = ''
				end
			end
		end
		
		table.insert(result, rc)
	end
	
	if not options.hist then --isolated はへ
		i_last = getlast()
		if data.flag_hahe[result_sp[i_last]] and getlast(i_last - 1) == 0 then
			result[i_last] = result_sp[i_last]
		end
	end
	
	local num_cap = 0
	for i, v in ipairs(result) do
		if not options.no_diacritics then
			v = v:gsub('%f[aiueo][aiueo][aiueo]%f[^aiueo]', data.tr_long)
		end
		if result_sp[i] == 'cap' then num_cap = num_cap + 1 end
		if num_cap > 0 then
			v = v:gsub('.[\128-\191]*', function(c)
				if num_cap <= 0 then return c end
				local uc = mw.ustring.upper(c)
				if c ~= uc then num_cap = num_cap - 1 end
				return uc
			end)
		end
		result[i] = v
	end
	return table.concat(result)
end

local function is_good_romaji(str)
	str = mw.ustring.gsub(str, '%A', '')
	return mw.ustring.match(str, '[^A-za-zĀĪŪĒŌāīūēō]') == nil
end

local function format_pos_romaji(rom,  pos)
	if pos == 'proper' then
		if mw.ustring.gmatch(rom, '%u') then return rom end
		return (mw.ustring.gsub(rom, '%f[%a]%a', mw.ustring.upper))
	elseif pos == 'prefix' then
		return (rom:gsub('%-?$', '-'))
	elseif pos == 'suffix' or pos == 'counter' or pos == 'classifier' then
		return (rom:gsub('^%-?', '-'))
	else
		return rom
	end
end

function export.tr(text, lang, sc)
	local rom_result
	
	local rom_title = export.kana_to_romaji(text)
	if not is_good_romaji(rom_title) then rom_title = nil end
	
	local pagetext = mw.title.new(text):getContent()
	if pagetext then
		for _, tn in ipairs{'noun', 'verb', 'verb%-suru', 'adj', 'phrase', 'combining form', 'verb form', 'see'} do
			if rom_title and pagetext:match('{{ja%-' .. tn .. '}}') then
				if rom_result and rom_result ~= rom_title then return rom_title end
				rom_result = rom_title
			end
			for t in pagetext:gmatch('{{ja%-' .. tn .. '(|..-})}') do
				local no_kana = true
				for tt in t:gmatch'%f[^|]..-%f[|}]' do
					if not tt:match'%D.*=' and not tt:match'%[%[' and not tt:match']]' then
						local rom = export.kana_to_romaji(tt)
						if is_good_romaji(rom) then
							no_kana = false
							if rom_result and rom_result ~= rom then return rom_title end
							rom_result = rom
						end
					end
				end
				if rom_title and no_kana then
					if rom_result and rom_result ~= rom_title then return rom_title end
					rom_result = rom_title
				end
			end
		end
		
		for t in pagetext:gmatch'{{ja%-pos|(..-})}' do
			local pos, ta = t:match'^(..-)(|..-})$'
			if ta then
				local no_kana = true
				for tt in ta:gmatch'%f[^|]..-%f[|}]' do
					if not tt:match'%D.*=' and not tt:match'%[%[' and not tt:match']]' then
						local rom = export.kana_to_romaji(tt)
						if is_good_romaji(rom) then
							no_kana = false
							rom = format_pos_romaji(rom, pos)
							if rom_result and rom_result ~= rom then return rom_title end
							rom_result = rom
						end
					end
				end
				if rom_title and no_kana then
					local rom = format_pos_romaji(rom_title, pos)
					if rom_result and rom_result ~= rom then return rom_title end
					rom_result = rom
				end
			elseif rom_title then
				local rom = format_pos_romaji(rom_title, t:sub(1, -2))
				if rom_result and rom_result ~= rom then return rom_title end
				rom_result = rom
			end
		end
		return rom_result or rom_title
	else
		return rom_title
	end
end

-- A hack to bypass [[mod:languages]] bug [[special:diff/72585061]]
local f_tr = export.tr
function export.tr(...)
	local rom = f_tr(...)
	if rom then
		local rom_m, n = rom:gsub(data.rom['っ'], '\'')
		return n > 0 and mw.getCurrentFrame():extensionTag('nowiki', rom_m) or rom
	end
end

return export
